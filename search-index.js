var searchIndex = {};
searchIndex["gc"] = {"doc":"Thread-local garbage-collected boxes (The `Gc&lt;T&gt;` type).","items":[[3,"Gc","gc","A garbage-collected pointer type over an immutable value.",null,null],[3,"GcCell","","A mutable memory location with dynamically checked borrow rules\nwhich can be used inside of a garbage collected pointer.",null,null],[3,"GcCellRefMut","","A wrapper type for a mutably borrowed value from a GcCell&lt;T&gt;",null,null],[5,"force_collect","","Immediately trigger a garbage collection on the current thread.",null,{"inputs":[],"output":null}],[0,"trace","","",null,null],[8,"Trace","gc::trace","The Trace trait which needs to be implemented on garbage collected objects",null,null],[10,"trace","","Mark all contained Gcs",0,null],[10,"root","","Increment the root-count of all contained Gcs",0,null],[10,"unroot","","Decrement the root-count of all contained Gcs",0,null],[11,"trace","collections::string","",1,null],[11,"root","","",1,null],[11,"unroot","","",1,null],[11,"trace","alloc::boxed","",2,null],[11,"root","","",2,null],[11,"unroot","","",2,null],[11,"trace","collections::vec","",3,null],[11,"root","","",3,null],[11,"unroot","","",3,null],[11,"trace","core::option","",4,null],[11,"root","","",4,null],[11,"unroot","","",4,null],[6,"GcCellRef","gc","A wrapper type for an immutably borrowed value from a GcCell&lt;T&gt;",null,null],[11,"new","","Constructs a new `Gc&lt;T&gt;`.",5,{"inputs":[{"name":"t"}],"output":{"name":"gc"}}],[11,"trace","","",5,null],[11,"root","","",5,null],[11,"unroot","","",5,null],[11,"clone","","",5,null],[11,"deref","","",5,null],[11,"drop","","",5,null],[11,"default","","",5,{"inputs":[],"output":{"name":"gc"}}],[11,"eq","","",5,null],[11,"ne","","",5,null],[11,"partial_cmp","","",5,null],[11,"lt","","",5,null],[11,"le","","",5,null],[11,"gt","","",5,null],[11,"ge","","",5,null],[11,"cmp","","",5,null],[11,"hash","","",5,null],[11,"fmt","","",5,null],[11,"fmt","","",5,null],[11,"fmt","","",5,null],[11,"from","","",5,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"new","","Creates a new `GcCell` containing `value`.",6,{"inputs":[{"name":"t"}],"output":{"name":"gccell"}}],[11,"into_inner","","Consumes the `GcCell`, returning the wrapped value.",6,null],[11,"borrow","","Immutably borrows the wrapped value.",6,null],[11,"borrow_mut","","Mutably borrows the wrapped value.",6,null],[11,"trace","","",6,null],[11,"root","","",6,null],[11,"unroot","","",6,null],[11,"deref","","",7,null],[11,"deref_mut","","",7,null],[11,"drop","","",7,null],[11,"default","","",6,{"inputs":[],"output":{"name":"gccell"}}],[11,"eq","","",6,null],[11,"ne","","",6,null],[11,"partial_cmp","","",6,null],[11,"lt","","",6,null],[11,"le","","",6,null],[11,"gt","","",6,null],[11,"ge","","",6,null],[11,"cmp","","",6,null],[11,"hash","","",6,null],[11,"fmt","","",6,null],[11,"fmt","","",6,null],[11,"from","","",6,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[14,"unsafe_empty_trace!","","This simple rule implements the trace methods such with empty\nimplementations - use this for marking types as not containing any Trace types!",null,null],[14,"custom_trace!","","This rule implements the trace method. You define a this parameter name, and\npass in a body, the body should call `mark` on every traceable element inside\nthe body, and the mark implementation will automatically delegate to the correct\nmethod on the argument.",null,null]],"paths":[[8,"Trace"],[3,"String"],[3,"Box"],[3,"Vec"],[4,"Option"],[3,"Gc"],[3,"GcCell"],[3,"GcCellRefMut"]]};
initSearch(searchIndex);
